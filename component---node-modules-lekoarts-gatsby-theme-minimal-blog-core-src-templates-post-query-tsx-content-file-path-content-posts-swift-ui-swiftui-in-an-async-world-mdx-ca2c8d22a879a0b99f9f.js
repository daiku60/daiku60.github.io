"use strict";(self.webpackChunkminimal_blog=self.webpackChunkminimal_blog||[]).push([[270],{4765:function(e,t,n){n.d(t,{F:function(){return d},Z:function(){return h}});var l=n(7294),a=n(8733),r=n(795),o=n(2685),i=n(6799),s=n(8871);var c=e=>{let{post:t}=e;return null};const u=["16px","8px","4px"].map((e=>"rgba(0, 0, 0, 0.1) 0px "+e+" "+e+" 0px"));var m=e=>{let{data:{post:t},children:n}=e;return(0,a.tZ)(o.Z,null,(0,a.tZ)(r.X6,{as:"h1",variant:"styles.h1"},t.title),(0,a.tZ)("p",{sx:{color:"secondary",mt:3,a:{color:"secondary"},fontSize:[1,1,2]}},(0,a.tZ)("time",null,t.date),t.tags&&(0,a.tZ)(l.Fragment,null," — ",(0,a.tZ)(i.Z,{tags:t.tags})),t.timeToRead&&" — ",t.timeToRead&&(0,a.tZ)("span",null,t.timeToRead," min read")),(0,a.tZ)("section",{sx:{my:5,".gatsby-resp-image-wrapper":{my:[4,4,5],borderRadius:"4px",boxShadow:u.join(", "),".gatsby-resp-image-image":{borderRadius:"4px"}},variant:"layout.content"}},n),(0,a.tZ)(c,{post:t}))};const d=e=>{var t,n,l;let{data:{post:r}}=e;return(0,a.tZ)(s.Z,{title:r.title,description:r.description?r.description:r.excerpt,image:r.banner?null===(t=r.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(l=n.resize)||void 0===l?void 0:l.src:void 0,pathname:r.slug,canonicalUrl:r.canonicalUrl})};function h(e){let{...t}=e;return l.createElement(m,t)}},6799:function(e,t,n){var l=n(8733),a=n(7294),r=n(1883),o=n(3494),i=n(9706);t.Z=e=>{let{tags:t}=e;const{tagsPath:n,basePath:s}=(0,o.Z)();return(0,l.tZ)(a.Fragment,null,t.map(((e,t)=>(0,l.tZ)(a.Fragment,{key:e.slug},!!t&&", ",(0,l.tZ)(r.Link,{sx:e=>{var t;return{...null===(t=e.styles)||void 0===t?void 0:t.a}},to:(0,i.Z)("/"+s+"/"+n+"/"+e.slug)},e.name)))))}},8871:function(e,t,n){var l=n(7294),a=n(1883),r=n(4232);t.Z=e=>{let{title:t="",description:n="",pathname:o="",image:i="",children:s=null,canonicalUrl:c=""}=e;const u=(0,r.Z)(),{siteTitle:m,siteTitleAlt:d,siteUrl:h,siteDescription:p,siteImage:w,author:g,siteLanguage:E}=u,f={title:t?t+" | "+m:d,description:n||p,url:""+h+(o||""),image:""+h+(i||w)};return l.createElement(l.Fragment,null,l.createElement("html",{lang:E}),l.createElement("title",null,f.title),l.createElement("meta",{name:"description",content:f.description}),l.createElement("meta",{name:"image",content:f.image}),l.createElement("meta",{property:"og:title",content:f.title}),l.createElement("meta",{property:"og:url",content:f.url}),l.createElement("meta",{property:"og:description",content:f.description}),l.createElement("meta",{property:"og:image",content:f.image}),l.createElement("meta",{property:"og:type",content:"website"}),l.createElement("meta",{property:"og:image:alt",content:f.description}),l.createElement("meta",{name:"twitter:card",content:"summary_large_image"}),l.createElement("meta",{name:"twitter:title",content:f.title}),l.createElement("meta",{name:"twitter:url",content:f.url}),l.createElement("meta",{name:"twitter:description",content:f.description}),l.createElement("meta",{name:"twitter:image",content:f.image}),l.createElement("meta",{name:"twitter:image:alt",content:f.description}),l.createElement("meta",{name:"twitter:creator",content:g}),l.createElement("meta",{name:"gatsby-theme",content:"@lekoarts/gatsby-theme-minimal-blog"}),l.createElement("link",{rel:"icon",type:"image/png",sizes:"32x32",href:(0,a.withPrefix)("/favicon-32x32.png")}),l.createElement("link",{rel:"icon",type:"image/png",sizes:"16x16",href:(0,a.withPrefix)("/favicon-16x16.png")}),l.createElement("link",{rel:"apple-touch-icon",sizes:"180x180",href:(0,a.withPrefix)("/apple-touch-icon.png")}),c?l.createElement("link",{rel:"canonical",href:c}):null,s)}},2543:function(e,t,n){n.r(t),n.d(t,{Head:function(){return i.F},default:function(){return s}});var l=n(7294),a=n(1151);function r(e){const t=Object.assign({p:"p",ul:"ul",li:"li",code:"code",h3:"h3",pre:"pre",a:"a",em:"em",strong:"strong",img:"img",h2:"h2"},(0,a.ah)(),e.components);return l.createElement(l.Fragment,null,l.createElement(t.p,null,"At TheLeftBit we've built great UIKit apps that have stood the test of time and scaled beautifully by following three basic rules:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"Keep it simple"),"\n",l.createElement(t.li,null,"Pass values to functions"),"\n",l.createElement(t.li,null,"Don't fight the platform"),"\n"),"\n",l.createElement(t.p,null,"Now, as we transition to SwiftUI, we're formalizing how things are structured in order for our developers to tackle creating beautiful user interfaces without too much fuzz. We wanted the code to adopt modern Swift concepts like Structured Concurrency, Result Builders and Generics in order to be even more efficient than what we where when building UIs with UIKit."),"\n",l.createElement(t.p,null,"We quickly came to the realization that in most modern apps, most of the Data and State is remote. It's behind some kind of HTTP call. And this fact should get first-citizen support in whatever patterns we chose."),"\n",l.createElement(t.p,null,"On the other hand, SwiftUI expects data to be stored and passed around the Views using property wrappers like ",l.createElement(t.code,null,"@State"),", ",l.createElement(t.code,null,"@Binding")," or ",l.createElement(t.code,null,"@Published"),' . To simplify this, one of the easiest ways is to store all the required properties in some "Data Model" object that stores all the properties using ',l.createElement(t.code,null,"@Published")," (not necessary if we were to target iOS 17 thanks to ",l.createElement(t.code,null,"Observable"),", but the gist is the same) and then pass that object into the ",l.createElement(t.code,null,"View")," either using simple injection in the initializer or an ",l.createElement(t.code,null,".environmentObject()")," call."),"\n",l.createElement(t.h3,null,"Simple Book List:"),"\n",l.createElement(t.p,null,"Let's keep in mind these two things, and build a simple SwiftUI view that shows a list of books that comes from a remote REST API."),"\n",l.createElement(t.p,null,"The ",l.createElement(t.code,null,"Book")," model looks like:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-swift"},"struct Book: Identifiable, Decodable {\n  let id: UUID\n  let title: String\n  let author: String\n}\n")),"\n",l.createElement(t.p,null,"After that, we need some object to hold all the books for the ",l.createElement(t.code,null,"View"),". We are calling it ",l.createElement(t.code,null,"DataModel")," in this example, but could be anything the team decides on. Let's create an ",l.createElement(t.code,null,"ObservableObject")," for this:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-swift"},"class DataModel: ObservableObject {    \n  @Published var isLoading: Bool\n  @Published var error: Swift.Error?\n  @Published var books: [Book]\n  init(isLoading: Bool = false, error: Error? = nil, books: [BookList.Book] = []) { ... }\n}\n")),"\n",l.createElement(t.p,null,"Now, let's display this in a list:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-swift"},"struct BookList: View {\n  \n  @ObservedObject var dataModel: DataModel\n  \n  var body: some View {\n    if dataModel.isLoading {\n      ProgressView()\n    } else let error = dataModel.error {\n      ErrorView(error)\n    } else {\n      List(dataModel.books, id: \\.id) { book in\n \tVStack {\n          Text(book.title)\n            .foregroundStyle(.primary)\n          Text(book.author)\n            .foregroundStyle(.secondary)\n      \t}\n      }\n    }\n  }\n}\n")),"\n",l.createElement(t.p,null,"This all compiles and similar code has been written in countless blog posts all over the internet. But a question come to mind:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"How do we populate that data?"),"\n"),"\n",l.createElement(t.p,null,"We could add to ",l.createElement(t.code,null,"DataModel"),"  an async function to populate the data:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-swift"},"extension DataModel {\n  func populateData() async {\n    self.isLoading = true\n    let request: URLRequest = { ... }\n    do {\n      let response = try await URLSession.shared.data(for: request).0\n      let books = try JSONDecoder().decode([Book].self, from: response)\n      self.books = books \n    } catch {\n      self.error = error\n    }\n    self.isLoading = false\n  }\n}\n")),"\n",l.createElement(t.p,null,"There's a lot of book-keeping going on. We have to make sure we're setting the correct loading state, capturing the error and storing the response in the ",l.createElement(t.code,null,"@Published")," property. Doable, but still, definitely improvable."),"\n",l.createElement(t.p,null,"And now we have to figure out a place to call this from the View to make sure it's populated. Thankfully, since iOS 15 we've had the ",l.createElement(t.code,null,".task()")," modifier, which allows us to run ",l.createElement(t.code,null,"async"),"  functions when the view is about to be rendered."),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-swift"},"struct BookList: View {\n  var body: some View {\n    { ... }\n    .task {\n      await dataModel.populateData()\n    }\n  }\n}\n")),"\n",l.createElement(t.p,null,"This works, and most people leave it like this and continue with their lives."),"\n",l.createElement(t.p,null,"But there are several code smells here:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"The ",l.createElement(t.code,null,"if {} else if {} else {}")," branch in the view's body will sure become more and more complex as we add features to this view.","\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"Imagine a new requirement to only show a special upsell banner in case the user doesn't have a subscription. ",l.createElement(t.a,{href:"https://en.wikipedia.org/wiki/Cyclomatic_complexity"},"Cyclomatic complexity")," is always something we have to be aware of and try to reduce."),"\n"),"\n"),"\n",l.createElement(t.li,null,"If we try to Preview this ",l.createElement(t.code,null,"View"),", it'll make a network call to populate it's data. This is not something you want to do for your production apps, since there might be Authentication required, but also, it's definetly not the ",l.createElement(t.em,null,"correct")," thing to do, since it makes your Previews unpredictable, and Previews should be treated as Unit Tests: they should succeed regardless of the network status of your machine."),"\n"),"\n",l.createElement(t.p,null,"So how do we address these issues?"),"\n",l.createElement(t.h3,null,"Async Initialization"),"\n",l.createElement(t.p,null,"The first breakthrough in the way we architecture SwiftUI apps was that we could add two initializers to our ",l.createElement(t.code,null,"DataModel")," objects:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"An async initalizer for when the view is run regularly."),"\n",l.createElement(t.li,null,"A sync initializer when the view is Previewed."),"\n"),"\n",l.createElement(t.p,null,"To continue with the previous example, we can now remove those pesky ",l.createElement(t.code,null,"var isLoading: Bool")," and ",l.createElement(t.code,null,"var error: Swift.Error?")," properties, the ",l.createElement(t.code,null,"populateData")," function and do:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-swift"},"extension DataModel {\n  \n  init(restAPIClient: RestAPIClient) async throws {\n    self.books = try await restAPIClient.fetchBookList()\n  }\n  \n  init(books: [Book]) {\n    self.books = books\n  }\n}\n")),"\n",l.createElement(t.p,null,"In the above example, let's assume that ",l.createElement(t.code,null,"RestAPIClient"),"  is an object that will perform all the ",l.createElement(t.code,null,"URLSession")," and JSON parsing work and return a parsed array of ",l.createElement(t.code,null,"Book")," in case the request is sent and parsed succesfully."),"\n",l.createElement(t.p,null,"We can now, from a Preview, create a ",l.createElement(t.code,null,"DataModel")," with mock Books and inject it in the View, allowing us to work the the View's layout without launching the App or sending network requests to servers."),"\n",l.createElement(t.p,null,"Like we say here at TheLeftBit, \"if Previews don't work, it's not SwiftUI!\""),"\n",l.createElement(t.p,null,"And, by removing the ",l.createElement(t.code,null,"loading")," and ",l.createElement(t.code,null,"error")," properties, plus annotating the initializer as ",l.createElement(t.code,null,"async throws")," we've moved the error and async handling a level up. This means that now ",l.createElement(t.code,null,"DataModel")," is not directly usable from ",l.createElement(t.code,null,"BookListView"),", since we can't set the ",l.createElement(t.code,null,"@ObservedObject")," of a view asynchronously. Which brings us to our second breakthrough:"),"\n",l.createElement(t.h3,null,"Async View"),"\n",l.createElement(t.p,null,"As we mentioned earlier, we need some async context to create the ",l.createElement(t.code,null,"DataModel")," before passing it to the ",l.createElement(t.code,null,"View"),"'s initializer.  And the best way to create this async context is using the ",l.createElement(t.code,null,".task")," view modifier, but for that we need to create a ",l.createElement(t.code,null,"View"),"."),"\n",l.createElement(t.p,null,"Let's wrap this async work in a ",l.createElement(t.code,null,"View"),": something like this would work:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-swift"},"struct BookListAsync: View {\n  \n  let restAPIClient: RestAPIClient\n  @State var loadingPhase = LoadingPhase.loading\n  \n  enum LoadingPhase {\n    case loading\n    case loaded(DataModel)\n    case failed(Swift.Error)\n  }\n  \n  var body: some View {\n    contentView\n    .task {\n      self.loadingPhase = .loading\n      do {\n        let dataModel = try await DataModel(restAPIClient: restAPIClient)\n        self.loadingPhase = .loaded(dataModel)\n      } catch {\n        self.loadingPhase = .failed(error)\n      }\n    }\n  }\n  \n  @ViewBuilder\n  private var contentView: some View {    \n    switch loadingPhase {\n    case .loading: \n      ProgressView()\n    case .failed(let error): \n      Text(error.localizedDescription)\n    case .loaded(let dataModel):\n      BookList(dataModel: dataModel)\n    }\n  }\n}\n")),"\n",l.createElement(t.p,null,"This is much better: we are using the  ",l.createElement(t.code,null,"LoadingPhase")," enum to model the what to show in the View: either a spinner, a message with the error or the actual ",l.createElement(t.code,null,"BookList"),". And, we are leveraging the ",l.createElement(t.code,null,".task")," modifier to perform the actual creation of the ",l.createElement(t.code,null,"DataModel"),"."),"\n",l.createElement(t.p,null,"This comes with a lot of advantages:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"The ",l.createElement(t.code,null,"BookList")," is only created when there is ",l.createElement(t.strong,null,"actual data")," to show. It made no semantical sense for it to be holding an empty array, much better to express that that Array is in a remote location by making the only way to get to it ",l.createElement(t.code,null,"async"),"."),"\n",l.createElement(t.li,null,"Once the ",l.createElement(t.code,null,"BookList")," is loaded and on-screen, any error that occurs after that (for example, marking a ",l.createElement(t.code,null,"Book")," as read) is handled on a completely different context from the loading error; reducing the overall complexity of the system."),"\n",l.createElement(t.li,null,"Since we are encapsulating the Async work in another ",l.createElement(t.code,null,"View"),", we'll be leveraging SwiftUI to cancel the Task in case the user is not interested anymore. For example, the user will dismiss this view using the back button of a NavigationStack, or swiping down a modal sheet. This will free resources and make sure the app is always performant."),"\n"),"\n",l.createElement(t.p,null,"This is already a lot better, but this ",l.createElement(t.code,null,"BookListAsync")," is tightly coupled to ",l.createElement(t.code,null,"BookList")," and it's ",l.createElement(t.code,null,"DataModel"),", making it impossible to reuse it with another view. We have two options to make this view reusable:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"Use Swift Macros to auto-generate the code"),"\n",l.createElement(t.li,null,"Use Generics to inject the View."),"\n"),"\n",l.createElement(t.p,null,"We discarted using Swift Macros since we were having trouble making the inputs of the view more flexible."),"\n",l.createElement(t.p,null,"The final component we built, using Swift Generics and applied to the ",l.createElement(t.code,null,"BookListAsync")," example, has the following API:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-swift"},"var body: some View {\n    AsyncView(\n        id: $viewID\n        dataGenerator: {\n            try await DataModel(restAPIClient: restAPIClient)\n        },\n        hostedViewGenerator: { dataModel in\n            BookList(dataModel: dataModel)\n        },\n        loadingViewGenerator: {\n            ProgressView()\n        },\n        errorViewGenerator: { error, onRetry in\n            Text(error.localizedDescription)\n        }\n    )\n}\n")),"\n",l.createElement(t.p,null,"Where the parameters are:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.code,null,"id"),": is the identifier passed to the ",l.createElement(t.code,null,".task(id:priority:_:)")," ",l.createElement(t.a,{href:"https://developer.apple.com/documentation/swiftui/view/task(id:priority:_:)"},"View Modifier"),". Having this parameter will allow us to reload the view if an upstream value changes. Think for example, a screen where the there are some sort of filter UI that triggers a new HTTP request to reload the contents of a list. This becomes trivial now.","\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"If the view will not be reloaded as a result of user input, you can safely pass a ",l.createElement(t.code,null,".constant()")," value here with a hardcoded string."),"\n"),"\n"),"\n",l.createElement(t.li,null,l.createElement(t.code,null,"dataGenerator"),": this closure will generate the data required by the view to render it's contents. If an error is thrown in this closure, the Error View will be shown."),"\n",l.createElement(t.li,null,l.createElement(t.code,null,"hostedViewGenerator"),": this closure will generate the view once the data it needs is available."),"\n",l.createElement(t.li,null,l.createElement(t.code,null,"loadingViewGenerator"),": this closure will generate the view that will be shown during the ",l.createElement(t.code,null,"dataGenerator")," execution."),"\n",l.createElement(t.li,null,l.createElement(t.code,null,"errorViewGenerator"),": this closure will generate the view that will be shown when an error is thrown.","\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"The ",l.createElement(t.code,null,"error")," is passed in order to make sure that the view can show an appropiate message. Also, an ",l.createElement(t.code,null,"onRetry")," closure is passed to make sure the user can retry the operation."),"\n"),"\n"),"\n"),"\n",l.createElement(t.p,null,"The implementation itself is not as interesting, you can check it out ",l.createElement(t.a,{href:"https://github.com/theleftbit/BSWInterfaceKit/blob/develop/Sources/BSWInterfaceKit/SwiftUI/Views/AsyncView.swift"},"here"),". Having this View allows us to architect our code in a much better way:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-swift"},"struct BookList: View {\n  @ObservedObject var dataModel: DataModel\n  var body: some View { ... }\n  \n  struct Async: View {\n      let restAPIClient: RestAPIClient\n      var body: some View {\n      \t  AsyncView(...)\n      }\n  }\n} \n")),"\n",l.createElement(t.p,null,"This makes sure that when using autocomplete, the developer ",l.createElement(t.strong,null,"won't find")," a way to create a ",l.createElement(t.code,null,"BookList")," without a ",l.createElement(t.code,null,"DataModel"),", and nudge him towards ",l.createElement(t.code,null,"BookList.Async"),"."),"\n",l.createElement(t.img,{src:"https://i.imgur.com/a4ya0JR.jpg",alt:""}),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Note:")," How the ",l.createElement(t.code,null,"RestAPIClient")," instance is injected in the ",l.createElement(t.code,null,"BookList.Async")," view is up to you; we're using simple value injection, but this could very well be an ",l.createElement(t.code,null,"@EnvironmentObject")," or anything else you and your team are using for Dependency Injection."),"\n",l.createElement(t.h2,null,"Conclusions:"),"\n",l.createElement(t.p,null,"These two breakthroughs have allowed us to iterate quickly, making sure everyday tasks are handled by this abstractions and allowing us to focus on what sets up each project apart."),"\n",l.createElement(t.p,null,"All of this, by still leveraging the same three concepts:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,"Keep it simple:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"A simple API and a simple abstraction allows developers of all seniority levels to use it."),"\n"),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,"Pass values to functions:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"How the dependencies are passed to the ",l.createElement(t.code,null,"Async")," view is up to the developer, but it's always evident what's happening."),"\n"),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,"Don't fight the platform:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"Leverage the platform (in this case SwiftUI) and it's primitives and data-flows, allowing our code to mature along the platform."),"\n"),"\n"),"\n"),"\n",l.createElement(t.p,null,"Thanks for reading and ",l.createElement(t.a,{href:"https://twitter.com/theleftbit"},"contact us")," in case you have any questions!"))}var o=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,a.ah)(),e.components);return t?l.createElement(t,e,l.createElement(r,e)):r(e)},i=n(4765);function s(e){return l.createElement(i.Z,e,l.createElement(o,e))}i.Z}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-swift-ui-swiftui-in-an-async-world-mdx-ca2c8d22a879a0b99f9f.js.map