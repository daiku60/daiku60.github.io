{
    "componentChunkName": "component---src-lekoarts-gatsby-theme-minimal-blog-core-templates-post-query-tsx",
    "path": "/content-configuration",
    "result": {"data":{"post":{"slug":"/content-configuration","title":"Migrating to UIContentConfiguration","date":"16.11.2021","tags":[{"name":"UIKit","slug":"ui-kit"},{"name":"CollectionView","slug":"collection-view"},{"name":"UIContentConfiguration","slug":"ui-content-configuration"}],"description":null,"canonicalUrl":"https://random-blog-about-curses-content.com","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"author\": \"daiku\",\n  \"title\": \"Migrating to UIContentConfiguration\",\n  \"date\": \"2021-11-16T00:00:00.000Z\",\n  \"slug\": \"/content-configuration\",\n  \"canonicalUrl\": \"https://random-blog-about-curses-content.com\",\n  \"tags\": [\"UIKit\", \"CollectionView\", \"UIContentConfiguration\"],\n  \"excerpt\": \"In this post we showcase how we are migrating our cells to the new `UIContentConfiguration` technique that's been available since iOS 14.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Initial state\"), mdx(\"p\", null, \"Before we talk about \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UIContentConfiguration\"), \", let's see the starting point we had, since you probably have something similar in your codebase:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"public class SimpleCollectionViewCell: UICollectionViewListCell {\\n    \\n    private var titleLabel: UILabel!\\n    private var subtitleLabel: UILabel!\\n    private var photoImageView: UIImageView!\\n    \\n    override init(frame: CGRect) {\\n        super.init(frame: frame)\\n        \\n        /// Layout Code\\n    }\\n    \\n    required init?(coder aDecoder: NSCoder) {\\n        fatalError(\\\"init(coder:) has not been implemented\\\")\\n    }\\n    \\n    override public var isSelected: Bool {\\n        didSet {\\n            if isSelected {\\n                contentView.backgroundColor = .cellSelectionBackgroundColor\\n            } else {\\n                contentView.backgroundColor = .defaultBackgroundColor\\n            }\\n        }\\n    }\\n    \\n    override public var isHighlighted: Bool {\\n        didSet {\\n            contentView.backgroundColor = isHighlighted ? UIColor.systemGray3 : .defaultBackgroundColor\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"As you can see in the defined properties, this cell has a couple of Labels and an Image View. To render it's contents, it defines a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ViewModel\"), \" and a method to configure it's subviews as such:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"extension SimpleCollectionViewCell {\\n    public struct ViewModel: Hashable {\\n        public let id: String\\n        public let photo: UIImage\\n        public let title: String\\n        public let subtitle: String?\\n    }\\n    \\n    public func configureFor(viewModel: ViewModel) {\\n        titleLabel.text = viewModel.title\\n        subtitleLabel.text = viewModel.subtitle\\n        photoImageView.image = viewModel.photo\\n    }\\n}\\n\")), mdx(\"p\", null, \"This means that when we dequeue the cell from the collectionView, we just need to call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"configureFor\"), \" method to properly populate our subviews with the data.\"), mdx(\"p\", null, \"Here we can see how we implement a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UICollectionDiffableDataSource\"), \", dequeueing this cell:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"let simpleCellRegistration = UICollectionView.CellRegistration<SimpleCollectionViewCell, SimpleCollectionViewCell.ViewModel> { (cell, indexPath, vm) in\\n    cell.configureFor(viewModel: vm)\\n}\\n\\nlet dataSource = UICollectionViewDiffableDataSource<Section, Item>.init(collectionView: collectionView) { (cv, indexPath, item) -> UICollectionViewCell? in\\n    switch item {\\n    case .simpleCell(let vm):\\n        return cv.dequeueConfiguredReusableCell(using: simpleCellRegistration, for: indexPath, item: vm)\\n        ...\\n    }\\n}\\n...\\nenum Section {\\n    case onlySection\\n}\\n\\nenum Item: Hashable {\\n    case simpleCell(SimpleCollectionViewCell.ViewModel)\\n}\\n\")), mdx(\"p\", null, \"We ensure the type passed to the cell is appropriate by making the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Item\"), \" contain that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SimpleCollectionViewCell.ViewModel\"), \", so that when we call the registration handler that type is the ViewModel for this particular item.\"), mdx(\"h2\", null, \"Moving to \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"UIContentConfiguration\")), mdx(\"p\", null, \"We want to migrate this \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ViewModel\"), \" to the new technique \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UIContentConfiguration\"), \", wich will handle not only the data the cell needs (id, photo, title and subtitle), but also the cell state, including our familiar properties when building lists such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isSelected\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isHighlighted\"), \".\"), mdx(\"p\", null, \"The great thing about this new protocol is that we'll be able to decouple our view layout from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UICollectionViewCell\"), \". This way, we'll have a composable structure that we can reuse elsewhere in our code, if need be.\"), mdx(\"p\", null, \"First we want to take a look at the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UIContentConfiguration\"), \" protocol:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"public protocol UIContentConfiguration {\\n\\n    /// Initializes and returns a new instance of the content view using this configuration.\\n    func makeContentView() -> UIView & UIContentView\\n\\n    /// Returns the configuration updated for the specified state, by applying the configuration's default values for that state to any properties that have not been customized.\\n    func updated(for state: UIConfigurationState) -> Self\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"makeContentView()\"), \" ensures that the configuration creates a new view to serve as a contentView for the cell. This view needs to be both a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UIView\"), \" and a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UIContentView\"), \", which enforces that the view has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UIContentConfiguration\"), \" stored. \")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"updated(for:)\"), \" returns a new configuration applying a given state. This will allow us to, for example, change the cell background color when the user taps it.\"))), mdx(\"p\", null, \"Our custom configuration will have to implement both functions. We'll define it as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"public struct Configuration: UIContentConfiguration {\\n    public let id: String\\n    public let photo: UIImage\\n    public let title: String\\n    public let subtitle: String?\\n    \\n    private(set) var state: UICellConfigurationState?\\n    \\n    public init(id: String, photo: UIImage, title: String, subtitle: String?, state: UICellConfigurationState? = nil) {\\n        self.id = id\\n        self.photo = photo\\n        self.title = title\\n        self.subtitle = subtitle\\n        self.state = state\\n    }\\n    \\n    public func makeContentView() -> UIView & UIContentView {\\n        View(configuration: self) // To be defined\\n    }\\n    \\n    public func updated(for state: UIConfigurationState) -> SimpleCell.Configuration {\\n        var mutableCopy = self\\n        if let cellState = state as? UICellConfigurationState {\\n            mutableCopy.state =  cellState\\n        }\\n        return mutableCopy\\n    }\\n    \\n}\\n\")), mdx(\"p\", null, \"Here we can see that we moved all the code in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ViewModel\"), \" struct into this new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Configuration\"), \" type. We also added the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"state\"), \" property on it, which will hold relevant properties such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isSelected\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isHighlighted\"), \". This object is created by UIKit when the user interacts with cells in lists.\"), mdx(\"p\", null, \"Also, you can see how simple the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"updated(for: UIConfigurationState)\"), \" function is. It's very straightforward: since we're using a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"struct\"), \" to hold this data, we can add a new variable and just use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"self\"), \" and let copy-on-write do it's job. This allows this function to just mutate the new properties, and returns a fresh copy for te view to be reconfigured.\"), mdx(\"p\", null, \"We also need to define our view. It must be both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UIView\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UIContentView\"), \". That in turn requires that it has a configuration set in. Furthermore, it will have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"init(configuration:)\"), \", so that it can be instantiantiated from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"makeView()\"), \" method.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"public class View: UIView & UIContentView {\\n    public var configuration: UIContentConfiguration\\n    \\n    ...\\n    \\n    init(configuration: Configuration) {\\n        self.configuration = configuration\\n        super.init(frame: .zero)\\n        ...\\n        // Layout Code\\n        \\n        configureFor(configuration: configuration)\\n    }\\n}\\n\")), mdx(\"p\", null, \"In the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"init\"), \" method, we'll also include all the layout code the previous \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SimpleCollectionViewCell\"), \" had. Note also that here we must configure the view, meaning populating its \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UILabel\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UIImageView\"), \", etc. with actual content, which is passed in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"init\"), \" method.\"), mdx(\"p\", null, \"This \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"configureFor(configuration:)\"), \" has basically the same code it had before, but it will also contain the code to style the state changes in the cell\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"public func configureFor(configuration: Configuration) {\\n    titleLabel.text = configuration.title\\n    subtitleLabel.text = configuration.subtitle\\n    photoImageView.image = configuration.photo\\n    if let state = configuration.state {\\n        backgroundColor = {\\n            if state.isSelected {\\n                return .cellSelectionBackgroundColor\\n            } else if state.isHighlighted {\\n                return .systemGray3\\n            } else {\\n                return .defaultBackgroundColor\\n            }\\n        }()\\n    } else {\\n        backgroundColor = .defaultBackgroundColor\\n    }\\n}\\n\")), mdx(\"p\", null, \"Note that here we merged the two properties related to state, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isSelected\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isHighlighted\"), \" in a single state change. State now doesn't have to be defined all over the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UIView\"), \" subclass, and it can be set from one single method, simplifiying a lot the code.\"), mdx(\"h3\", null, \"How are changes in the configuration affect the view?\"), mdx(\"p\", null, \"So far we saw how we create a cell using the configuration. But if we tap on the cell, the background is not being changed. This is because we lack the last piece of the puzzle: Updates.\"), mdx(\"p\", null, \"As we can see from the updated(for state:) method, we can mutate the configuration whenever a change is needed. This in turn will change the instance of the configuration defined in SimpleCellView. But that does not change any views yet. So we need to set a trigger for that to happen. So we add a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"didSet\"), \" trigger to the SimpleCellView's configuration:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"public var configuration: UIContentConfiguration {\\n    didSet {\\n        guard let oldConfig = oldValue as? Configuration,\\n              let config = configuration as? Configuration else { return }\\n        if oldConfig != config {\\n            self.configureFor(configuration: config)\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"Here we make sure that if the configuration really changed, we call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"configureFor(configuration: config)\"), \". To do this, we need to make \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Configuration\"), \" conform to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Equatable\"), \" as well. But aside from that, we just need to call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"configureFor(configuration:)\"), \" again to see the change take effect.\"), mdx(\"p\", null, \"And thats really it! Here you can se the complete code.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"public enum SimpleCell {\\n    public struct Configuration: UIContentConfiguration, Identifiable, Equatable {\\n        public let id: String\\n        public let photo: UIImage\\n        public let title: String\\n        public let subtitle: String?\\n        \\n        private(set) var state: UICellConfigurationState?\\n        \\n        public init(id: String, photo: UIImage, title: String, subtitle: String?, state: UICellConfigurationState? = nil) {\\n            self.id = id\\n            self.photo = photo\\n            self.title = title\\n            self.subtitle = subtitle\\n            self.state = state\\n        }\\n        \\n        public func makeContentView() -> UIView & UIContentView {\\n            View(configuration: self)\\n        }\\n        \\n        public func updated(for state: UIConfigurationState) -> SimpleCell.Configuration {\\n            var mutableCopy = self\\n            if let cellState = state as? UICellConfigurationState {\\n                mutableCopy.state =  cellState\\n            }\\n            return mutableCopy\\n        }\\n        \\n    }\\n    \\n    public class View: UIView & UIContentView {\\n        public var configuration: UIContentConfiguration\\n        private var titleLabel: UILabel!\\n        private var subtitleLabel: UILabel!\\n        private var photoImageView: UIImageView!\\n        \\n        init(configuration: Configuration) {\\n            self.configuration = configuration\\n            super.init(frame: .zero)\\n            ...\\n            // Layout Code\\n            \\n            configureFor(configuration: configuration)\\n        }\\n        \\n        public func configureFor(configuration: Configuration) {\\n            titleLabel.text = configuration.title\\n            subtitleLabel.text = configuration.subtitle\\n            photoImageView.image = configuration.photo\\n            \\n            if let state = configuration.state {\\n                backgroundColor = {\\n                    if state.isSelected {\\n                        return .cellSelectionBackgroundColor\\n                    } else if state.isHighlighted {\\n                        return .systemGray3\\n                    } else {\\n                        return .defaultBackgroundColor\\n                    }\\n                }()\\n            } else {\\n                backgroundColor = .defaultBackgroundColor\\n            }\\n        }\\n    }\\n}\\n\")), mdx(\"h3\", null, \"How do we use that in our \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"UICollectionViewDiffableDataSource\"), \"?\"), mdx(\"p\", null, \"At this point, we already have a working \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UIView\"), \" with all it's inputs and outputs defined. At this stage, we recommend adding \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/pointfreeco/swift-snapshot-testing\"\n  }, \"snapshot tests\"), \" to make sure the view looks exactly like you'd expect. \"), mdx(\"p\", null, \"Now, to use this view as a cell in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UICollectionView\"), \", there's a secret that we haven't told you: beggining iOS 14 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UICollectionViewCell\"), \" defines a new property:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"@available(iOS 14.0, tvOS 14.0, *)\\nextension UICollectionViewCell {\\n    @available(iOS 14.0, tvOS 14.0, *)\\n    public var contentConfiguration: UIContentConfiguration?\\n}\\n\")), mdx(\"p\", null, \"The documentation states that:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Setting a content configuration replaces the existing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"contentView\"), \" of the cell with a new content view instance from the configuration, or directly applies the configuration to the existing content view if the configuration is compatible with the existing content view type.\")), mdx(\"p\", null, \"This means that it'll rip out it's contentView, and use the view provided by your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UIContentConfiguration\"), \" in it's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"makeContentView()\"), \" method. No more subclasses of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UICollectionViewCell\"), \" \\uD83C\\uDF89!!!\"), mdx(\"p\", null, \"Now that we know this, our registration and dequeue process looks much like the same as before, but applying the configuration instead:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"let simpleCellRegistration = UICollectionView.CellRegistration<UICollectionViewCell, UIContentConfiguration> { (cell, _, configuration) in\\n    cell.contentConfiguration = configuration\\n}\\n\\nlet dataSource = UICollectionViewDiffableDataSource<Section, Item>.init(collectionView: collectionView) { (cv, indexPath, item) -> UICollectionViewCell? in\\n    switch item {\\n    case .simpleCell(let configuration):\\n        return cv.dequeueConfiguredReusableCell(using: simpleCellRegistration, for: indexPath, item: configuration)\\n        ...\\n    }\\n}\\n\")), mdx(\"p\", null, \"We do need to change how the dataSource's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Item\"), \" is defined:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"enum Item: Hashable {\\n    case simpleCell(SimpleCell.Configuration)\\n}    \\n\")), mdx(\"p\", null, \"Now we store the actual \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SimpleCell.Configuration\"), \" we defined previously.\"), mdx(\"p\", null, \"Also, UIKit is now in charge for some changes on that configuration: in the case for a state change, UIKit will immediatly call SimpleCell.Configuration \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"updated(for state:)\"), \" method, which in turn will update the configuration on the SimpleCell.View and call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"configureFor(configuration:)\"), \", so everything is kept in sync. \"), mdx(\"p\", null, \"Moreover, if there's a data change and we need to call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reconfigureItems()\"), \" on the dataSource, the cell will be dequeued, which will set the configuration again, calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"updated(for state:)\"), \".\"), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"With that, is as simple as changing types wherever we used \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SimpleCollectionViewCell\"), \" to the new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SimpleCell.View\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SimpleCollectionViewCell.ViewModel\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SimpleCell.Configuration\"), \".\"), mdx(\"p\", null, \"And that's it! Using that structure we can now implement the same things we previously had, without the hassle of having all the state properties attached to the view, all while relying on UIKit to do the heavy lifting of deciding when to update content and state.\"), mdx(\"h2\", null, \"Bonus Track: SwiftUI\"), mdx(\"p\", null, \"You might be wondering: \\\"is this change worth it? What's in it for me?\\\"\"), mdx(\"p\", null, \"Moving to this architecture GREATLY improves the experience when bridging these views to SwiftUI. It should be as simple as:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"import SwiftUI\\n\\nextension SimpleCell {\\n \\n    struct SwiftUIView: UIViewRepresentable {\\n        \\n        let config: Configuration\\n                \\n        func makeUIView(context: Context) -> SimpleCell.View {\\n            config.makeContentView() as! SimpleCell.View\\n        }\\n        \\n        func updateUIView(_ uiView: SimpleCell.View, context: Context) {\\n            uiView.configureFor(configuration: config)\\n        }\\n        \\n        typealias UIViewType = SimpleCell.View\\n    }\\n}\\n\")), mdx(\"p\", null, \"A little more of code should be required to handle updates to this view, but should not be hard, let's leave that as homework \\uD83D\\uDE05.\"), mdx(\"p\", null, \"This data-driven approach tricklying in UIKit it's greatly appreciated and makes it easy to maintain UIKit projects.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"In this post we showcase how we are migrating our cells to the new `UIContentConfiguration` technique that's been available since iOS 14.","timeToRead":4,"banner":null,"parent":{"frontmatter":{"author":"daiku"}}}},"pageContext":{"slug":"/content-configuration","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}